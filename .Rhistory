library('fitdistrplus')
library('compositions')
library('plot3D')
library('quantmod')
library('VineCopula')
library('copula')
library('fitdistrplus')
library('compositions')
library('plot3D')
library('quantmod')
library('VineCopula')
library('copula')
getPercentChangesByYear <- function(symbol, startYear)
{
allData = getSymbols.yahoo(symbol, auto.assign=FALSE)
relevantColumn = names(allData)[length(names(allData))]
values = allData[,relevantColumn]
values = values[paste(startYear, '::')]
percentChanges = dailyReturn(values)
return(percentChanges)
}
getPercentChanges <- function(symbol)
{
allData = getSymbols.yahoo(symbol, auto.assign=FALSE)
relevantColumn = names(allData)[length(names(allData))]
values = allData[,relevantColumn]
values = values['2010::']
percentChanges = dailyReturn(values)
return(percentChanges)
}
getBestTDistDegreesOfFreedom <- function(vectorOfValues)
{
vectorOfValues = scale(vectorOfValues)#(vectorOfValues - mean(vectorOfValues)) / sd(vectorOfValues)
result = fitdistr(vectorOfValues, "t")
bestDegreesOfFreedom = result$estimate[3]
return (bestDegreesOfFreedom)
}
getMarginalDensity <- function(copula_dist, indexOfVariableWeWantMargDistFor, vectorOfValuesToConditionOn)
{
#vectorOfValuesToConditionOn has 0 at indexOfVariableWeWantMargDistFor (in addition to possibly zeroes elsewhere as well)
conditionalPDF = c()
xVals = seq(-10, 10, .01)
for(value in xVals)
{
thisPoint = vectorOfValuesToConditionOn
thisPoint[indexOfVariableWeWantMargDistFor] = value
densityAtThisPoint = dMvdc(thisPoint, copula_dist, log = FALSE)
conditionalPDF = c(conditionalPDF, densityAtThisPoint)
}
conditionalPDF = conditionalPDF / sum(conditionalPDF)
return ( list ( v1 = xVals, v2 = conditionalPDF   ) )
}
inverseCDF <- function(pdfVector, pdfXValues,  totalArea)
{
endIndex = length(pdfVector)
for(index in 1:length(pdfVector))
{
if( sum( pdfVector[ index : endIndex] ) < totalArea)
return(pdfXValues[index])
}
}
#Get all data
SPX = getPercentChanges('^GSPC')
SAVE = getPercentChanges('SAVE')
USO = getPercentChanges('USO') #oil etf
XLY = getPercentChanges('XLY') #consumer discretionary etf
allData = as.matrix(cbind(SPX, XLY, USO))
allData = allData[complete.cases(allData),]
namesList = c('^GSPC' , 'XLY', "USO")
origCorr = cor(allData)
#Select copula
u <- pobs(allData)[,1]
v <- pobs(allData)[,2]
selectedCopula <- BiCopSelect(u,v,familyset=NA)
selectedCopula
cop <- claytonCopula(dim = dim(allData)[2])
cop <- claytonCopula(dim = dim(allData)[2])
pseudoObs <- pobs(allData)
fit <- fitCopula(cop, pseudoObs, method='ml')
coef(fit)
param <- coef(fit)[1]
persp(claytonCopula(dim = dim(allData)[2], param = claytonParam),dCopula)
claytonParam <- coef(fit)[1]
persp(claytonCopula(dim = dim(allData)[2], param = claytonParam),dCopula)
dim(allData)[2]
claytonParam
claytonCopula(dim = dim(allData)[2], param = claytonParam)
persp(claytonCopula(dim = dim(allData)[2], param = claytonParam), dCopula)
u <- rCopula(3965, claytonCopula(dim = dim(allData)[2], param = claytonParam))
plot(u[,1],u[,2],pch='.',col='blue') # (2D only)
cor(u,method='spearman') #Should be close to origCorr
means = colMeans(allData)
stdDevs =  apply(allData, 2, sd)
listOfDegreesOfFreedom = matrix(0, nrow = ncol(allData))
for( index in 1 : length(listOfDegreesOfFreedom))
{
listOfDegreesOfFreedom[index] = getBestTDistDegreesOfFreedom(as.matrix(allData[,index]))
}
standardizedAllData = scale(allData)
#Visualize fit
for( index in 1 : length(listOfDegreesOfFreedom))
{
hist(standardizedAllData[,index],breaks=80,main=namesList[index],freq=F,density=30,col='cyan', xlim = c(-4, 4) )
lines(seq(-4, 4, .1),dt(seq(-4, 4, .1), listOfDegreesOfFreedom[index]),col='red',lwd=2)
legend('topright',paste('Fitted T(', toString(listOfDegreesOfFreedom[index]) , ')' ),col=c('red'),lwd=2)
}
copula_dist <- mvdc(copula = claytonCopula(dim = dim(allData)[2], param = claytonParam), margins = marginalsList,
paramMargins=paramMarginsList )
sim <- rMvdc(1000, copula_dist)
# See: https://www.r-bloggers.com/modelling-dependence-with-copulas-in-r/ for refference
library('fitdistrplus')
library('compositions')
library('plot3D')
library('quantmod')
library('VineCopula')
library('copula')
getPercentChangesByYear <- function(symbol, startYear)
{
allData = getSymbols.yahoo(symbol, auto.assign=FALSE)
relevantColumn = names(allData)[length(names(allData))]
values = allData[,relevantColumn]
values = values[paste(startYear, '::')]
percentChanges = dailyReturn(values)
return(percentChanges)
}
getPercentChanges <- function(symbol)
{
allData = getSymbols.yahoo(symbol, auto.assign=FALSE)
relevantColumn = names(allData)[length(names(allData))]
values = allData[,relevantColumn]
values = values['2010::']
percentChanges = dailyReturn(values)
return(percentChanges)
}
getBestTDistDegreesOfFreedom <- function(vectorOfValues)
{
vectorOfValues = scale(vectorOfValues)#(vectorOfValues - mean(vectorOfValues)) / sd(vectorOfValues)
result = fitdistr(vectorOfValues, "t")
bestDegreesOfFreedom = result$estimate[3]
return (bestDegreesOfFreedom)
}
getMarginalDensity <- function(copula_dist, indexOfVariableWeWantMargDistFor, vectorOfValuesToConditionOn)
{
#vectorOfValuesToConditionOn has 0 at indexOfVariableWeWantMargDistFor (in addition to possibly zeroes elsewhere as well)
conditionalPDF = c()
xVals = seq(-10, 10, .01)
for(value in xVals)
{
thisPoint = vectorOfValuesToConditionOn
thisPoint[indexOfVariableWeWantMargDistFor] = value
densityAtThisPoint = dMvdc(thisPoint, copula_dist, log = FALSE)
conditionalPDF = c(conditionalPDF, densityAtThisPoint)
}
conditionalPDF = conditionalPDF / sum(conditionalPDF)
return ( list ( v1 = xVals, v2 = conditionalPDF   ) )
}
inverseCDF <- function(pdfVector, pdfXValues,  totalArea)
{
endIndex = length(pdfVector)
for(index in 1:length(pdfVector))
{
if( sum( pdfVector[ index : endIndex] ) < totalArea)
return(pdfXValues[index])
}
}
#Get all data
SPX = getPercentChanges('^GSPC')
SAVE = getPercentChanges('SAVE')
USO = getPercentChanges('USO') #oil etf
XLY = getPercentChanges('XLY') #consumer discretionary etf
allData = as.matrix(cbind(SPX, XLY, USO))
allData = allData[complete.cases(allData),]
namesList = c('^GSPC' , 'XLY', "USO")
origCorr = cor(allData)
#Select copula
u <- pobs(allData)[,1]
v <- pobs(allData)[,2]
selectedCopula <- BiCopSelect(u,v,familyset=NA)
selectedCopula
#Fit copula
cop <- claytonCopula(dim = dim(allData)[2])
pseudoObs <- pobs(allData)
fit <- fitCopula(cop, pseudoObs, method='ml')
coef(fit)
#For Clayton coula
claytonParam <- coef(fit)[1]
#For t-copula
# rho <- coef(fit)[1]
# df <- coef(fit)[2]
#Plot copula density (for kicks) (2D only)
# persp(tCopula(dim = 2,rho,df=df),dCopula)
persp(claytonCopula(dim = dim(allData)[2], param = claytonParam), dCopula)
#Build copula
u <- rCopula(3965, claytonCopula(dim = dim(allData)[2], param = claytonParam))
# u <- rCopula(3965, tCopula(dim = dim(allData)[2],rho,df=df))
plot(u[,1],u[,2],pch='.',col='blue') # (2D only)
cor(u,method='spearman') #Should be close to origCorr
#Get marginal distributions
means = colMeans(allData)
stdDevs =  apply(allData, 2, sd)
listOfDegreesOfFreedom = matrix(0, nrow = ncol(allData))
for( index in 1 : length(listOfDegreesOfFreedom))
{
listOfDegreesOfFreedom[index] = getBestTDistDegreesOfFreedom(as.matrix(allData[,index]))
}
standardizedAllData = scale(allData)
#Visualize fit
for( index in 1 : length(listOfDegreesOfFreedom))
{
hist(standardizedAllData[,index],breaks=80,main=namesList[index],freq=F,density=30,col='cyan', xlim = c(-4, 4) )
lines(seq(-4, 4, .1),dt(seq(-4, 4, .1), listOfDegreesOfFreedom[index]),col='red',lwd=2)
legend('topright',paste('Fitted T(', toString(listOfDegreesOfFreedom[index]) , ')' ),col=c('red'),lwd=2)
}
#Now apply copula
paramList = list()
for( index in 1 : length(listOfDegreesOfFreedom))
{
paramList = list(paramList, list(df = listOfDegreesOfFreedom[index]))
}
marginalsList = c()
for(index in 1:(dim(allData)[2]))
{
marginalsList = c(marginalsList, "t")
}
paramMarginsList = c()
for(index in 1:(dim(allData)[2]))
{
paramMarginsList = c(paramMarginsList, list(df = listOfDegreesOfFreedom[index]))
}
copula_dist
copula_dist <- mvdc(copula = claytonCopula(dim = dim(allData)[2], param = claytonParam), margins = marginalsList,
paramMargins=paramMarginsList )
sim <- rMvdc(1000, copula_dist)
plot(standardizedAllData[,1],standardizedAllData[,2],main='Returns')
points(sim[,1],sim[,2],col='red')
legend('bottomright',c('Observed','Simulated'),col=c('black','red'),pch=21)
plot(standardizedAllData[,1],standardizedAllData[,2],main='Returns')
points(sim[,2],sim[,3],col='red')
legend('bottomright',c('Observed','Simulated'),col=c('black','red'),pch=21)
plot(standardizedAllData[,1],standardizedAllData[,2],main='Returns')
points(sim[,1],sim[,3],col='red')
legend('bottomright',c('Observed','Simulated'),col=c('black','red'),pch=21)
indexOfFirstVariable = 1
indexOfSecondVariable = 2
xVals = seq(min(standardizedAllData[,indexOfFirstVariable]), max(standardizedAllData[,indexOfFirstVariable]), (max(standardizedAllData[,indexOfFirstVariable]) - min(standardizedAllData[,indexOfFirstVariable])) / 50)
yVals = seq(min(standardizedAllData[,indexOfSecondVariable]), max(standardizedAllData[,indexOfSecondVariable]), (max(standardizedAllData[,indexOfSecondVariable]) - min(standardizedAllData[,indexOfSecondVariable])) / 50)
densities = matrix(0 , nrow = length(xVals), ncol = length(yVals))
for (xIndex in 1:length(xVals))
{
for(yIndex in 1:length(yVals))
{
xVal = xVals[xIndex]
yVal = yVals[yIndex]
densities[xIndex, yIndex] =  dMvdc(c(xVal, yVal), copula_dist, log = FALSE)
}
}
xVals = xVals * stdDevs[1] + means[1]
yVals = yVals * stdDevs[2] + means[2]
persp3D(xVals, yVals, densities, phi = 30, theta = 30, ticktype = "detailed",
xlab = paste("\n", namesList[1]), ylab = paste("\n", namesList[2]), zlab = "\n\nProbability",
facets = FALSE, plot = FALSE)
vectorOfConditionalValues = c(0, -.05, -.05)
standardizedConditionalValues = (vectorOfConditionalValues - means) / stdDevs
standardizedConditionalValues[1] = 0 #Dependent variable needs value of 0
l <- getMarginalDensity(copula_dist, 1, standardizedConditionalValues )
standardizedConditionalXValues = l[[1]]
conditionalDist = l[[2]]
conditionalXValues = standardizedConditionalXValues * stdDevs[1] + means[1]
portfolio.hist <- hist(allData[,1], plot=FALSE, breaks = length(conditionalXValues))
portfolio.hist$counts <- portfolio.hist$counts/sum(portfolio.hist$counts)
plot(portfolio.hist, col = 'cyan',  main = namesList[1], xlab = namesList[1], ylab = 'Probability')
lines(conditionalXValues , conditionalDist ,col='red',lwd=2)
unconditionalVaR = inverseCDF(portfolio.hist$counts, portfolio.hist$mids,  .95)
conditionalVaR = inverseCDF(conditionalDist, conditionalXValues,  .95)
unconditionalVaR
conditionalVaR
